
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Week 11: 프로덕션 에이전트 시스템 &#8212; Deep Learning for NLP 2025</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-examples.css?v=e236af4b" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/language_selector.css?v=6a8ebae4" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../_static/tabs.js?v=3ee01567"></script>
    <script src="../_static/js/hoverxref.js"></script>
    <script src="../_static/js/tooltipster.bundle.min.js"></script>
    <script src="../_static/js/micromodal.min.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-BQJE5V9RK2"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BQJE5V9RK2');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BQJE5V9RK2');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'week11/index';</script>
    <script src="../_static/language_switcher.js?v=730be77c"></script>
    <script src="../_static/chat.js?v=f0de43d7"></script>
    <link rel="icon" href="https://assets.entelecheia.ai/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Week 12: AI 규제와 책임 있는 AI" href="../week12/index.html" />
    <link rel="prev" title="Week 10: 정렬 기법의 발전" href="../week10/index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <script src="/_static/language_switcher.js"></script>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
<div class="sidebar-lang-select">  <nav class="menu">    <ul class="clearfix">      <li class="current-item">        <a href="#" class="clicker">          한국어 <span class="arrow">&#9660;</span>        </a>        <ul class="sub-menu">                    <li><a href="#" onclick="switchLanguage('en'); return false;">English</a></li>          <li><a href="#" onclick="switchLanguage('ko'); return false;">한국어</a></li>        </ul>      </li>    </ul>  </nav></div>
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Deep Learning for NLP 2025</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    딥러닝자연어처리 (131307379A)
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Lecture Notes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../week01/index.html">Week 1: Transformer 및 차세대 아키텍처</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../week01/qna.html">Transformer, Mamba, RWKV, Jamba 아키텍처 Q&amp;A</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../week02/index.html">Week 2: PyTorch 2.x와 최신 딥러닝 프레임워크</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week03/index.html">Week 3: 현대적 PEFT 기법을 활용한 효율적 파인튜닝</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week04/index.html">Week 4: 고급 프롬프트 기법과 최적화</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week05/index.html">Week 5: LLM 평가 패러다임과 벤치마크</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week06/index.html">Week 6: 멀티모달 NLP의 발전</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week07/index.html">Week 7: 초장문맥 처리와 효율적 추론</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week08/index.html">Week 8: 핵심 복습 및 최신 동향</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week09/index.html">Week 9: 고급 RAG 아키텍처</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week10/index.html">Week 10: 정렬 기법의 발전</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Week 11: 프로덕션 에이전트 시스템</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week12/index.html">Week 12: AI 규제와 책임 있는 AI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week13/index.html">Week 13: 온톨로지와 AI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../week14/index.html">Week 14: 2025년 NLP 현황: 확장 모델에서 능동 에이전트로</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Workshops</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../workshops/index.html">LLM From Scratch 워크숍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../workshops/week01.html">1주차 워크숍: LLM 개요 및 개발 환경 구축</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Projects</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../projects/index.html">프로젝트 운영 가이드라인</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../syllabus/index.html">강의계획서</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">Who made this book?</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/entelecheia/deepnlp-2025" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/entelecheia/deepnlp-2025/edit/main/book/ko/week11/index.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/entelecheia/deepnlp-2025/issues/new?title=Issue%20on%20page%20%2Fweek11/index.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/week11/index.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Week 11: 프로덕션 에이전트 시스템</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">1. 서론: 2025년, 프로덕션 에이전트 시스템의 새벽</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qa-llm-mas">1.1. 패러다임 전환: 단일 QA 봇에서 멀티 에이전트 시스템(LLM-MAS)으로</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#llm">1.2. 2025년 시장 동향: “에이전트 우선” LLM의 부상</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">1.3. “프로덕션”의 진정한 의미: “신뢰”와의 전투</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">2. 멀티 에이전트 협업 아키텍처의 이론적 기초</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">2.1. 주요 아키텍처 패턴 상세 분석</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai">3. CrewAI: 역할 기반 협업 오케스트레이션</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">3.1. 핵심 철학: 역할 기반 자율성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crews-vs-flows">3.2. 2025년 핵심 아키텍처: “Crews” vs “Flows”</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">3.3. 상태 관리의 중요성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai-amp-agent-management-platform">3.4. 엔터프라이즈 동향: CrewAI AMP(Agent Management Platform)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mirascope-pydantic">4. Mirascope: Pydantic을 통한 타입 안전성</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">4.1. 프로덕션 병목: 비구조화된 LLM 출력의 신뢰성 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mirascope-pydantic-i-o">4.2. Mirascope의 해결책: Pydantic을 통한 구조화된 I/O</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sdk">4.3. 네이티브 SDK와 비교한 압도적 단순성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#haystack-agents-rag">5. Haystack Agents: 도메인 특화 “에이전트형 RAG”</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-rag-rag">5.1. RAG의 진화: 수동적 RAG에서 능동적 “에이전트형 RAG”로</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conditionalrouter">5.2. 핵심 구성 요소: ConditionalRouter</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">6. 로우코드 통합 플랫폼과 “프로토타이핑 함정”</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#flowise-langflow-n8n">6.1. 비주얼 워크플로우 빌더(Flowise, LangFlow, n8n)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">6.2. 2025년의 냉혹한 현실: “프로토타이핑 함정”</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#llm-toolformer">7. LLM 내재적 능력의 진화: Toolformer에서 차세대 함수 호출로</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vs">7.1. 두 가지 접근법: 외재적 프레임워크 vs 내재적 능력</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#toolformer">7.2. 기초 연구: Toolformer와 자기 지도 학습</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gorilla-llm-berkeley-function-calling-leaderboard-bfcl">7.3. 2025년 현황: Gorilla LLM과 Berkeley Function Calling Leaderboard(BFCL)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mast-2025">8. 프로덕션 에이전트는 왜 실패하는가? - MAST 실패 분류법(2025)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mast-3">8.1. MAST: 3가지 주요 실패 범주와 실제 사례</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">8.2. 핵심 표: MAST - 멀티 에이전트 시스템 실패 분류법(2025)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">9. [실습] 자동화된 고객 지원 시스템 프로토타입 설계</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">9.1. 목표</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#flow-calls-rag-calls-crew">9.2. 아키텍처 청사진: “Flow-calls-RAG-calls-Crew” 하이브리드</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">9.3. 1단계: 데이터 무결성 정의(Mirascope + Pydantic)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai-flows">9.4. 2단계: 전체 오케스트레이션(CrewAI Flows)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#faq-haystack-rag">9.5. 3.1단계: 1차 응답 - FAQ 봇(Haystack 에이전트형 RAG)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai-crew">9.6. 3.2단계: 2차 응답 - 티켓팅 크루(CrewAI Crew)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">9.7. 실습 아키텍처 요약</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">10. 부록: 핵심 프레임워크 및 플랫폼 비교</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">10.1. 핵심 표 2: 2025년 멀티 에이전트 프레임워크 비교</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">10.2. 핵심 표 3: 로우코드 플랫폼 프로덕션 준비도 평가</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">참고자료</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="week-11">
<h1>Week 11: 프로덕션 에이전트 시스템<a class="headerlink" href="#week-11" title="Link to this heading">#</a></h1>
<section id="id1">
<h2>1. 서론: 2025년, 프로덕션 에이전트 시스템의 새벽<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<section id="qa-llm-mas">
<h3>1.1. 패러다임 전환: 단일 QA 봇에서 멀티 에이전트 시스템(LLM-MAS)으로<a class="headerlink" href="#qa-llm-mas" title="Link to this heading">#</a></h3>
<p>2023년과 2024년이 RAG(Retrieval-Augmented Generation)를 통해 “LLM이 무엇을 아는가”에 초점을 맞춘 “정보 검색” 시대였다면, 2025년은 “LLM이 무엇을 할 수 있는가”에 집중하는 “작업 실행” 시대로 정의된다. 기업들은 더 이상 LLM을 단순한 Q&amp;A 챗봇으로 사용하는 것에 만족하지 않는다. 여러 LLM 에이전트가 협력하여 복잡한 비즈니스 프로세스를 자동화하는 LLM 기반 멀티 에이전트 시스템(LLM-MAS)으로 이동하고 있다.</p>
<p>이러한 변화는 단순한 트렌드가 아니라 프로덕션 환경에서 실제로 적용되고 있다. LangChain의 “State of AI Agents” 보고서에 따르면, 2025년 기준으로 업계 전문가의 51%가 이미 프로덕션에서 AI 에이전트를 사용하고 있다. 특히 중소기업(100~2000명)의 63%가 적극적으로 에이전트를 도입하고 있어, 에이전트 시스템이 더 이상 실험실 장난감이 아님을 증명하고 있다.</p>
</section>
<section id="llm">
<h3>1.2. 2025년 시장 동향: “에이전트 우선” LLM의 부상<a class="headerlink" href="#llm" title="Link to this heading">#</a></h3>
<p>이러한 산업적 수요가 LLM 모델 자체의 진화를 이끌고 있다. 2025년 초, Anthropic의 Claude 3.7 Sonnet과 Opus 4 모델 출시는 시장에 “에이전트 우선(agent-first)”이라는 새로운 개념을 도입했다. 이는 LLM이 단순히 텍스트를 생성하는 것을 넘어서, 외부 도구 사용, 자율적 행동 수행, 복잡한 코드 생성이라는 전제 하에 초기 설계 단계부터 개발되고 있음을 의미한다.</p>
<p>특히 Claude Code 모델은 개발자들 사이에서 코드 생성 작업의 시장 점유율 42%를 차지했으며, 이는 OpenAI(21%)의 두 배 이상이다. 이는 에이전트 시스템의 “첫 번째 킬러 앱”이 코드 생성 및 자동화 작업임을 명확히 보여준다.</p>
</section>
<section id="id2">
<h3>1.3. “프로덕션”의 진정한 의미: “신뢰”와의 전투<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<p>그러나 프로덕션 도입 추진 배경에는 심각한 신뢰 문제가 있다. 약 70%의 조직이 LLM 사용 사례를 적극적으로 탐색하거나 구현하고 있지만, 실제 에이전트 배포는 자율주행차를 도로에 내보내는 것과 유사한 수준의 위험 관리가 필요하다.</p>
<p>IBM 전문가 Ashoori는 “오늘날 에이전트를 사용한다는 것은 기본적으로 LLM을 가져와서 자신을 대신하여 행동을 취하도록 허용하는 것”이라고 강조하며, 시스템은 첫날부터 “신뢰할 수 있고 감사 가능한” 방식으로 구축되어야 한다고 말한다. Deloitte의 2025 Technology Trends 보고서도 시스템 접근 권한을 가진 에이전트의 확산이 “사이버보안”과 “위험”에서 근본적인 패러다임 전환을 요구한다고 경고한다.</p>
<p>따라서 2025년 프로덕션 에이전트 시스템의 핵심 과제는 “성능”이 아니라 “제어”와 “신뢰”다. 기업의 51%가 에이전트를 사용한다는 사실은 성공을 의미하는 것이 아니라 오히려 “도전의 시작”을 의미한다. 그들 중 많은 기업이 이 강의에서 나중에 논의될 “프로토타이핑 함정”이나 “MAST 실패 분류법”과 같은 실제 문제에 직면하고 있다. 이 강의의 궁극적인 목표는 단순히 “작동하는” 에이전트를 구축하는 것이 아니라, “신뢰할 수 있고 제어 가능한” 프로덕션 시스템을 구축하기 위한 엔지니어링 방법론을 배우는 것이다.</p>
</section>
<section id="id3">
<h3>체크포인트 질문<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>2025년 “작업 실행” 시대가 이전 “정보 검색” 시대와 어떻게 구별되는가?</p></li>
<li><p>프로덕션 에이전트 시스템에서 신뢰와 제어가 성능보다 더 중요한 이유는 무엇인가?</p></li>
<li><p>LLM 개발 맥락에서 “에이전트 우선”이 무엇을 의미하며, 왜 중요한가?</p></li>
</ul>
</section>
</section>
<section id="id4">
<h2>2. 멀티 에이전트 협업 아키텍처의 이론적 기초<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>CrewAI나 LangGraph와 같은 프레임워크를 학습하기 전에, 이들이 구현하려는 근본적인 협업 아키텍처 패턴을 이해하는 것이 중요하다. 아키텍처 선택은 “유연성”과 “제어/디버깅 가능성” 사이의 근본적인 트레이드오프를 결정한다.</p>
<p>2025년 프로덕션 환경은 무엇보다 예측 가능성과 감사 가능성을 우선시한다. 따라서 높은 유연성을 제공하지만 제어하기 어려운 “네트워크” 패턴보다 “감독자(Supervisor)” 또는 “계층적(Hierarchical)” 패턴이 압도적으로 선호된다.</p>
<section id="id5">
<h3>2.1. 주요 아키텍처 패턴 상세 분석<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p><strong>1. 감독자/매니저 → 워커 패턴</strong></p>
<ul class="simple">
<li><p><strong>구조</strong>: 중앙 “감독자” 에이전트가 다른 모든 에이전트를 조정하며, 작업 분배 및 라우팅 결정을 관리한다.</p></li>
<li><p><strong>핵심</strong>: “작업 분해”에서 우수한 성능을 보인다. 복잡한 작업을 병렬화 가능한 청크로 분해하고, 이를 전문 “워커” 에이전트에 할당한 다음 결과를 집계한다.</p></li>
<li><p><strong>응용</strong>: 작업 분해가 명확한 시나리오에 최적이다. 대규모 문서 처리 파이프라인, 웹 스크래핑, OCR 워크플로우 등이 그 예이다. MetaGPT와 같은 프레임워크가 이 접근법을 정제했다.</p></li>
</ul>
<p><strong>2. 계층적 패턴</strong></p>
<ul class="simple">
<li><p><strong>구조</strong>: 매니저가 워커를 관리하는 것을 넘어서, 매니저가 다른 하위 매니저를 관리하는 트리 구조를 가진다. “HALO”와 같은 최근 2025년 연구가 이 구조의 효율성을 입증했다.</p></li>
<li><p><strong>핵심</strong>: 복잡한 다층 작업을 대규모 에이전트 그룹으로 확장할 수 있으며, 명확한 책임 위임을 허용한다.</p></li>
<li><p><strong>응용</strong>: 복잡한 소프트웨어 개발 프로젝트나 다부서 비즈니스 프로세스 자동화에 적합하다.</p></li>
</ul>
<p><strong>3. 네트워크 및 커스텀 워크플로우 패턴</strong></p>
<ul class="simple">
<li><p><strong>네트워크</strong>: 모든 에이전트가 서로 자유롭게 통신할 수 있다. 이는 유연성을 극대화하고 창의적인 브레인스토밍에 유용할 수 있지만, 에이전트 수가 증가함에 따라 조정 복잡성이 폭발적으로 증가하여 프로덕션 제어에 부적합하다.</p></li>
<li><p><strong>커스텀 워크플로우</strong>: 에이전트가 미리 정의된 규칙에 따라 다른 에이전트의 특정 하위 집합과만 통신한다. 예측 가능성이 보장되어야 하는 성능 중심 도메인 워크플로우(예: 금융 거래 시스템)에서 사용된다.</p></li>
</ul>
</section>
<section id="id6">
<h3>체크포인트 질문<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>서로 다른 멀티 에이전트 아키텍처 패턴 간의 근본적인 트레이드오프는 무엇인가?</p></li>
<li><p>프로덕션 환경에서 감독자와 계층적 패턴이 네트워크 패턴보다 선호되는 이유는 무엇인가?</p></li>
<li><p>커스텀 워크플로우 패턴이 감독자 패턴보다 더 적절한 경우는 언제인가?</p></li>
</ul>
</section>
</section>
<section id="crewai">
<h2>3. CrewAI: 역할 기반 협업 오케스트레이션<a class="headerlink" href="#crewai" title="Link to this heading">#</a></h2>
<section id="id7">
<h3>3.1. 핵심 철학: 역할 기반 자율성<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>CrewAI는 멀티 에이전트 시스템을 “팀”으로 조직하는 비유를 사용한다. 각 에이전트에 명확한 역할을 할당하여 에이전트가 자율적으로 협업하도록 설계되었다. 모든 에이전트는 세 가지 핵심 속성을 가진다:</p>
<ol class="arabic simple">
<li><p><strong>role</strong>: “무엇을 하는가?” (예: 시니어 리서처)</p></li>
<li><p><strong>goal</strong>: “무엇을 달성해야 하는가?” (예: 특정 주제에 대한 최신 정보 수집)</p></li>
<li><p><strong>backstory</strong>: “어떤 경험을 가지고 있는가?” (예: 20년 경력의 베테랑 분석가)</p></li>
</ol>
<p>이 backstory는 단순한 장식 텍스트가 아니다. LLM이 그 페르소나에 더 깊이 몰입하여 일관되고 고품질의 응답을 생성하도록 안내하는 강력한 프롬프트 엔지니어링 기법이다. 시스템은 네 가지 핵심 구성 요소로 구성된다: “Crew”(팀), “Agents”(팀원), “Tasks”(과제), “Process”(작업 절차).</p>
</section>
<section id="crews-vs-flows">
<h3>3.2. 2025년 핵심 아키텍처: “Crews” vs “Flows”<a class="headerlink" href="#crews-vs-flows" title="Link to this heading">#</a></h3>
<p>2025년 기준으로 CrewAI는 단순한 “Crew” 프레임워크를 넘어 프로덕션 환경의 다양한 요구를 해결하는 이중 아키텍처를 제공하도록 진화했다.</p>
<p><strong>CrewAI Crews:</strong></p>
<ul class="simple">
<li><p><strong>개념</strong>: 자율성과 협업 지능에 최적화된 “팀”</p></li>
<li><p><strong>특징</strong>: 에이전트가 다음에 무엇을 할지 스스로 결정하고 동적으로 상호작용한다(예: 계층적 프로세스).</p></li>
<li><p><strong>적합한 경우</strong>: 창의적 콘텐츠 생성, 개방형 연구, 전략 개발과 같은 <em>유동적이고 탐구적인</em> 작업</p></li>
</ul>
<p><strong>CrewAI Flows:</strong></p>
<ul class="simple">
<li><p><strong>개념</strong>: 세밀하고 이벤트 기반 제어를 제공하는 “워크플로우”</p></li>
<li><p><strong>특징</strong>: 작업 순서와 상태 전환이 명시적으로 정의되고 결정적으로 실행된다. “Crews”는 복잡한 하이브리드 사용을 위해 이러한 “Flows” 내에서 한 단계로 호출될 수 있다.</p></li>
<li><p><strong>적합한 경우</strong>: API 오케스트레이션 및 데이터 처리 파이프라인과 같이 감사가 필요한 <em>명확하게 정의되고 예측 가능한</em> 작업</p></li>
</ul>
<p>“Flows”의 등장은 CrewAI가 “프로토타입” 수준에서 “프로덕션” 수준으로 성숙해진 중요한 지표다. 초기 에이전트 시스템은 자율성에 초점을 맞췄지만, 이는 “예측 불가능성”과 “디버깅 어려움”이라는 치명적인 결함으로 이어졌다. LangGraph와 같은 프레임워크가 “상태 기반 그래프”로 제어 가능한 대안을 제공하여 인기를 얻으면서, CrewAI는 “Flows”를 도입하여 결정적 워크플로우에 대한 시장 수요에 대응했다. 이는 개발자가 이제 작업의 성격에 따라 “자율성” vs “제어” 수준을 유연하게 선택할 수 있음을 의미한다.</p>
</section>
<section id="id8">
<h3>3.3. 상태 관리의 중요성<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>멀티 에이전트 시스템에서 “State”는 에이전트 간 정보를 전달하고 컨텍스트를 유지하는 핵심 “공유 메모리”다. “CrewAI Flows”는 Pydantic 모델(구조화된 상태) 또는 딕셔너리(비구조화된 상태)를 통해 이 상태를 명시적으로 관리한다.</p>
<p>예를 들어, 한 에이전트의 작업 결과(예: FAQ 봇)가 상태 객체의 특정 필드를 <code class="docutils literal notranslate"><span class="pre">status=&quot;escalated&quot;</span></code>로 변경하면, 이 상태 변경은 트리거 역할을 하여 다음 에이전트(예: 티켓 발행 봇)가 작업을 시작할 수 있게 한다. 이는 프로덕션 수준의 오케스트레이션을 가능하게 한다.</p>
</section>
<section id="crewai-amp-agent-management-platform">
<h3>3.4. 엔터프라이즈 동향: CrewAI AMP(Agent Management Platform)<a class="headerlink" href="#crewai-amp-agent-management-platform" title="Link to this heading">#</a></h3>
<p>CrewAI는 오픈소스(OSS)를 넘어 “AMP”라는 엔터프라이즈 상용 플랫폼을 제공하도록 확장하고 있다. AMP는 사용자가 “비주얼 에디터”와 “AI 코파일럿”을 사용하여 코드 작성 없이(No-Code) 에이전트 크루를 구축할 수 있는 GUI 환경을 제공한다. 이는 숙련된 개발자뿐만 아니라 주제 전문가(SME)도 에이전트 워크플로우 구축에 직접 참여할 수 있도록 하여 기업 내 AI 도입을 가속화하는 것을 목표로 한다.</p>
</section>
<section id="id9">
<h3>체크포인트 질문<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>CrewAI 에이전트의 세 가지 핵심 속성은 무엇이며, backstory 속성이 프롬프트 엔지니어링 기법으로 어떻게 작동하는가?</p></li>
<li><p>CrewAI Crews와 Flows의 주요 차이점은 무엇이며, 각각은 언제 사용해야 하는가?</p></li>
<li><p>상태 관리가 멀티 에이전트 시스템에서 프로덕션 수준의 오케스트레이션을 어떻게 가능하게 하는가?</p></li>
</ul>
</section>
</section>
<section id="mirascope-pydantic">
<h2>4. Mirascope: Pydantic을 통한 타입 안전성<a class="headerlink" href="#mirascope-pydantic" title="Link to this heading">#</a></h2>
<section id="id10">
<h3>4.1. 프로덕션 병목: 비구조화된 LLM 출력의 신뢰성 문제<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<p>LLM의 근본적인 출력은 “문자열”이다. 프로덕션 시스템에서 이 예측 불가능한 문자열을 파싱하여 다음 논리 단계를 실행하는 것은 극도로 불안정하며 시스템 실패의 핵심 원인이다.</p>
<p>이는 “에이전트 간 불일치(Inter-Agent Misalignment)” 문제와 직접적으로 연결된다. 예를 들어, 한 에이전트가 YAML 형식으로 응답을 반환하고 다음 에이전트가 JSON 형식을 기대하는 경우, 이 작은 형식 불일치로 인해 전체 워크플로우가 즉시 실패한다.</p>
</section>
<section id="mirascope-pydantic-i-o">
<h3>4.2. Mirascope의 해결책: Pydantic을 통한 구조화된 I/O<a class="headerlink" href="#mirascope-pydantic-i-o" title="Link to this heading">#</a></h3>
<p>Mirascope는 “타입 안전성”을 통해 이 만성적인 문제를 직접 해결한다.</p>
<p>핵심 메커니즘은 <code class="docutils literal notranslate"><span class="pre">&#64;llm.call</span></code> 데코레이터와 <code class="docutils literal notranslate"><span class="pre">response_model</span></code> 인수를 포함한다. 개발자는 먼저 LLM에서 원하는 출력 형식을 Pydantic BaseModel로 정의한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pydantic</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseModel</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Book</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">author</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@llm</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">provider</span><span class="o">=</span><span class="s2">&quot;openai&quot;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-4o-mini&quot;</span><span class="p">,</span> <span class="n">response_model</span><span class="o">=</span><span class="n">Book</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_book</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Extract </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># 이 함수는 문자열이 아닌 &#39;Book&#39; 객체 인스턴스를 반환한다.</span>
<span class="n">book_object</span><span class="p">:</span> <span class="n">Book</span> <span class="o">=</span> <span class="n">extract_book</span><span class="p">(</span><span class="s2">&quot;The Name of the Wind by Patrick Rothfuss&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 코드가 실행되면 Mirascope는 백그라운드에서 두 가지 핵심 작업을 자동으로 수행한다:</p>
<ol class="arabic simple">
<li><p><strong>자동 스키마 주입</strong>: Book Pydantic 모델을 LLM이 이해할 수 있는 JSON 스키마로 변환하고 프롬프트에 자동으로 주입한다. 이는 OpenAI의 “tools” 매개변수와 유사하다.</p></li>
<li><p><strong>자동 검증 및 파싱</strong>: LLM이 반환한 JSON 형식 응답을 검증하고 파싱하여 Book Pydantic 객체 인스턴스로 변환하며, 타입이 보장된 객체로 반환한다.</p></li>
</ol>
</section>
<section id="sdk">
<h3>4.3. 네이티브 SDK와 비교한 압도적 단순성<a class="headerlink" href="#sdk" title="Link to this heading">#</a></h3>
<p>Mirascope를 사용하면 LLM 호출을 “타입 안전한 Python 함수”처럼 다룰 수 있다. 네이티브 SDK를 사용할 때 필요한 <em>모든 보일러플레이트 코드</em>—복잡한 “tools” 정의, “tool_choice” 설정, <code class="docutils literal notranslate"><span class="pre">client.chat.completions.create</span></code> 호출, 응답 <code class="docutils literal notranslate"><span class="pre">message.content</span></code> 파싱 등—가 추상화된다. 이를 통해 개발자는 비즈니스 로직(Pydantic 모델 정의)에만 집중할 수 있다.</p>
<p>Mirascope는 LLM을 “신뢰할 수 없는 텍스트 생성기”에서 “신뢰할 수 있는 객체 인스턴스 생성기”로 승격시킨다. 멀티 에이전트 시스템은 본질적으로 소프트웨어이며, 소프트웨어는 예측 가능한 인터페이스(API)에서 작동한다. 예측 불가능한 텍스트를 반환하는 LLM은 안정적인 API가 될 수 없다. 그러나 Mirascope는 LLM의 출력에 “필수 스키마”(Pydantic)를 적용하여 LLM 호출이 <code class="docutils literal notranslate"><span class="pre">str</span></code>이 아닌 검증된 Book 객체를 반환하도록 보장한다. 이는 LLM을 전통적인 소프트웨어 엔지니어링 영역에 통합하고, “에이전트 간 불일치” 실패를 근원에서 방지하는 가장 강력한 방법을 제공하는 중요한 다리 역할을 한다.</p>
</section>
<section id="id11">
<h3>체크포인트 질문<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>비구조화된 LLM 출력이 멀티 에이전트 시스템에서 프로덕션 병목이 되는 이유는 무엇인가?</p></li>
<li><p>Mirascope의 <code class="docutils literal notranslate"><span class="pre">response_model</span></code> 매개변수가 에이전트 간 불일치 문제를 어떻게 해결하는가?</p></li>
<li><p>Mirascope가 Pydantic 모델을 사용하여 LLM 호출을 수행할 때 자동으로 수행하는 두 가지 프로세스는 무엇인가?</p></li>
</ul>
</section>
</section>
<section id="haystack-agents-rag">
<h2>5. Haystack Agents: 도메인 특화 “에이전트형 RAG”<a class="headerlink" href="#haystack-agents-rag" title="Link to this heading">#</a></h2>
<section id="rag-rag-rag">
<h3>5.1. RAG의 진화: 수동적 RAG에서 능동적 “에이전트형 RAG”로<a class="headerlink" href="#rag-rag-rag" title="Link to this heading">#</a></h3>
<p>Haystack는 RAG(Retrieval-Augmented Generation) 파이프라인 구축에 특화된 선도적인 오픈소스 프레임워크다. Haystack의 에이전트 구성 요소 정의는 표준 정의를 따른다: LLM(뇌), Tools(상호작용), Memory(컨텍스트), Reasoning(계획).</p>
<p>Haystack의 2025년 핵심 개념은 “에이전트형 RAG(Agentic RAG)”다. 이는 단순한 선형 “검색-증강-생성” 파이프라인을 넘어서 RAG 파이프라인 자체에 <em>능동적 의사결정 능력</em>을 부여하는 것을 의미한다.</p>
</section>
<section id="conditionalrouter">
<h3>5.2. 핵심 구성 요소: ConditionalRouter<a class="headerlink" href="#conditionalrouter" title="Link to this heading">#</a></h3>
<p>“에이전트형 RAG”를 구현하기 위한 핵심 기술은 파이프라인 내의 “조건부 라우팅(Conditional Routing)”이다. Haystack의 ConditionalRouter 구성 요소가 이 역할을 수행한다.</p>
<p><strong>사례 연구: “웹 검색으로 폴백” 아키텍처</strong></p>
<p>에이전트형 RAG의 가장 대표적인 구현 패턴은 “웹 검색으로 폴백(Fallback to Websearch)”이다.</p>
<ol class="arabic simple">
<li><p><strong>초기 RAG</strong>: 사용자의 쿼리(<span class="math notranslate nohighlight">\(Query\)</span>)를 받아 내부 기업 문서 저장소에서 관련 문서를 검색한다.</p></li>
<li><p><strong>의사결정 프롬프트</strong>: LLM에 명시적으로 지시한다. “제공된 문서로 답변할 수 없다면 다른 말을 하지 말고 <em>오직</em> ‘no_answer’ 키워드만 반환하라.”</p></li>
<li><p><strong>라우터(핵심)</strong>: ConditionalRouter 구성 요소가 LLM의 응답을 가로챈다.</p></li>
<li><p><strong>분기</strong>:</p>
<ul class="simple">
<li><p><strong>IF (답변 성공)</strong>: LLM이 유효한 답변(“no_answer”가 아님)을 생성하면, ConditionalRouter는 이 답변을 사용자에게 전달하고 파이프라인을 정상적으로 종료한다.</p></li>
<li><p><strong>IF (답변 실패, “no_answer” 반환)</strong>: ConditionalRouter가 이 키워드를 감지하고 사용자의 <em>원본 쿼리</em>(<span class="math notranslate nohighlight">\(Query\)</span>)를 SerperDevWebSearch와 같은 *다른 도구(웹 검색)*로 라우팅한다.</p></li>
</ul>
</li>
<li><p><strong>2차 RAG</strong>: 웹 검색 결과를 기반으로 새로운 답변이 생성되어 사용자에게 전달된다.</p></li>
</ol>
<p>이 에이전트형 RAG 아키텍처는 RAG의 만성적 문제인 “검색 실패 시 환각”을 해결하는 프로덕션 표준이다. 전통적인 RAG는 “작업 검증” 단계가 없기 때문에, 검색된 문서가 저품질이더라도 LLM은 이를 기반으로 그럴듯하게 들리는 거짓말을 생성한다. 이는 사용자가 감지하기 어려운 “얕은 검사 실패”의 전형적인 예이다.</p>
<p>Haystack의 “에이전트형 RAG”는 명시적인 “no*answer” 신호를 사용하여 파이프라인에 <em>검증 단계</em>를 내장한다. ConditionalRouter는 이 검증 결과에 따라 행동하는 “판단(Judge)” 에이전트 역할을 한다. 이는 RAG 시스템의 신뢰성을 “찾으면 좋고, 못 찾으면 그만”이라는 수동적 태도에서 “찾지 못하면 계획 B(웹 검색)를 실행하라”는 *능동적 문제 해결_ 접근 방식으로 향상시킨다.</p>
</section>
<section id="id12">
<h3>체크포인트 질문<a class="headerlink" href="#id12" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>전통적인 RAG와 에이전트형 RAG의 주요 차이점은 무엇인가?</p></li>
<li><p>ConditionalRouter 구성 요소가 RAG 파이프라인에서 능동적 의사결정을 어떻게 가능하게 하는가?</p></li>
<li><p>“no_answer” 검증 단계가 RAG 시스템에서 환각을 방지하는 데 왜 중요한가?</p></li>
</ul>
</section>
</section>
<section id="id13">
<h2>6. 로우코드 통합 플랫폼과 “프로토타이핑 함정”<a class="headerlink" href="#id13" title="Link to this heading">#</a></h2>
<section id="flowise-langflow-n8n">
<h3>6.1. 비주얼 워크플로우 빌더(Flowise, LangFlow, n8n)<a class="headerlink" href="#flowise-langflow-n8n" title="Link to this heading">#</a></h3>
<p>Flowise AI, LangFlow, n8n과 같은 플랫폼은 사용자가 “드래그 앤 드롭” GUI(그래픽 사용자 인터페이스)를 사용하여 에이전트 워크플로우를 시각적으로 설계할 수 있게 한다.</p>
<p>이는 CrewAI나 LangGraph와 같은 코드 중심 프레임워크에 비해 진입 장벽이 훨씬 낮아, 아이디어를 빠르게 검증하기 위한 “빠른 프로토타이핑”에 강력한 이점을 제공한다.</p>
<ul class="simple">
<li><p><strong>n8n</strong>: AI 에이전트 기능을 1000개 이상의 전통적인 비즈니스 자동화 통합(CRM, 이메일, Slack 등)과 결합하는 데 고유한 강점이 있다.</p></li>
<li><p><strong>Flowise/LangFlow</strong>: LangChain 생태계를 시각적으로 구현하는 데 초점을 맞춘다.</p></li>
</ul>
</section>
<section id="id14">
<h3>6.2. 2025년의 냉혹한 현실: “프로토타이핑 함정”<a class="headerlink" href="#id14" title="Link to this heading">#</a></h3>
<p>그러나 2025년 현장 데이터는 이러한 도구들이 프로덕션 환경에 적용될 때 심각한 한계에 부딪힌다고 경고한다. ZenML의 보고서와 개발자 커뮤니티의 피드백은 이를 “프로토타이핑 함정”이라고 부른다.</p>
<p><strong>사례 연구: LangFlow의 프로덕션 한계</strong></p>
<ol class="arabic simple">
<li><p><strong>메모리 누수</strong>: LangFlow의 캐싱 메커니즘에는 알려진 메모리 누수 문제가 있다. 파일이 반복적으로 업로드되거나 구성 요소가 재구축될 때 메모리 사용량이 두 배로 증가하여 대용량 문서를 처리하는 RAG 파이프라인에서 빈번한 애플리케이션 크래시를 유발한다.</p></li>
<li><p><strong>확장성 및 동시성 문제</strong>: 여러 동시 LLM 쿼리를 처리할 때 심각한 지연 시간과 100% CPU 사용률을 보여 실제 서비스 트래픽을 처리할 수 없음을 드러낸다.</p></li>
<li><p><strong>파일 업로드 제한</strong>: RAG 시스템에 필수적인 파일 업로드 용량이 기본적으로 100MB로 제한되어 대규모 지식 기반 구축이 어렵다.</p></li>
</ol>
<p>이러한 한계로 인해 경험 많은 개발자들은 LangFlow와 같은 플랫폼을 “프로토타이핑 및 다른 팀에 로직을 보여주기 위한 시각적 데모”로만 사용하고, 프로덕션 배포를 위해 “Python 코드로 모든 것을 다시 작성하는” 워크플로우를 따르고 있다.</p>
<p>궁극적으로 LangFlow와 같은 로우코드 플랫폼의 가치는 “배포”가 아닌 “설계”와 “소통”에 있다. GUI의 “편의성”이 프로덕션 “신뢰성”, “확장성”, “유지보수성”과 트레이드오프 관계에 있음을 인식해야 한다.</p>
</section>
<section id="id15">
<h3>체크포인트 질문<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>프로토타이핑을 위한 로우코드 비주얼 워크플로우 빌더의 주요 이점은 무엇인가?</p></li>
<li><p>“프로토타이핑 함정”이 무엇이며, LangFlow와 같은 플랫폼에서 왜 발생하는가?</p></li>
<li><p>경험 많은 개발자들이 프로덕션을 위해 로우코드 프로토타입을 Python으로 다시 작성하는 이유는 무엇인가?</p></li>
</ul>
</section>
</section>
<section id="llm-toolformer">
<h2>7. LLM 내재적 능력의 진화: Toolformer에서 차세대 함수 호출로<a class="headerlink" href="#llm-toolformer" title="Link to this heading">#</a></h2>
<section id="vs">
<h3>7.1. 두 가지 접근법: 외재적 프레임워크 vs 내재적 능력<a class="headerlink" href="#vs" title="Link to this heading">#</a></h3>
<p>지금까지 논의한 프레임워크(CrewAI, Haystack)는 LLM “외부”에서 에이전트 로직을 제어하는 “외재적(extrinsic)” 프레임워크다. 이와 대조적으로, Toolformer를 시작으로 <em>LLM 자체 내부</em>에 도구 사용 능력을 “내재화(intrinsic)”하는 연구가 활발히 진행되고 있다.</p>
</section>
<section id="toolformer">
<h3>7.2. 기초 연구: Toolformer와 자기 지도 학습<a class="headerlink" href="#toolformer" title="Link to this heading">#</a></h3>
<p>Toolformer의 목표는 LLM이 인간의 개입 없이 API(도구)를 호출할 시점을 <em>스스로</em> 학습하는 것이었다. 핵심 아이디어는 “손실 기반 필터링(Loss-Based Filtering)”이라는 독창적인 자기 지도 학습 방법이었다.</p>
<ol class="arabic simple">
<li><p>거대한 평문 코퍼스(<span class="math notranslate nohighlight">\(C\)</span>)로 시작한다.</p></li>
<li><p>모델 자체가 무작위 [API 호출] 후보를 샘플링하며, “이 위치에서 API(예: 계산기)를 호출하면 어떨까?”라고 생각한다.</p></li>
<li><p>API를 <em>실제로 실행</em>하여 <span class="math notranslate nohighlight">\(Result\)</span>를 얻는다.</p></li>
<li><p><strong>필터링(핵심)</strong>: 원본 텍스트에 `` 텍스트 스니펫을 삽입했을 때 그 <em>이후</em>에 오는 <em>원본 텍스트</em>(<span class="math notranslate nohighlight">\(C\)</span>)에 대한 예측 손실이 <em>크게 감소하는지</em> 확인한다.</p></li>
<li><p><strong>의미</strong>: 이는 모델이 <em>스스로</em> API 호출과 그 결과가 미래 텍스트 예측에 <em>유용한</em> 힌트인지 검증하는 과정이다.</p></li>
<li><p>유용하다고 판단된 API 호출(손실이 감소한 것)만 유지하여 새로운 데이터셋(<span class="math notranslate nohighlight">\(C^*\)</span>)을 생성한다. 그런 다음 모델을 이 데이터셋으로 파인튜닝한다.</p></li>
</ol>
</section>
<section id="gorilla-llm-berkeley-function-calling-leaderboard-bfcl">
<h3>7.3. 2025년 현황: Gorilla LLM과 Berkeley Function Calling Leaderboard(BFCL)<a class="headerlink" href="#gorilla-llm-berkeley-function-calling-leaderboard-bfcl" title="Link to this heading">#</a></h3>
<p>Toolformer의 아이디어는 2025년 “함수 호출(Function Calling)”이라는 이름으로 상용화되고 발전했다.</p>
<ul class="simple">
<li><p><strong>Gorilla LLM</strong>: API 호출 작성에만 <em>전문적으로</em> 파인튜닝된 LLaMA 기반 모델이다. 벤치마크에서 GPT-4보다 더 정확하게 API 호출을 생성하는 능력을 입증했다.</p></li>
<li><p><strong>BFCL(Berkeley Function Calling Leaderboard)</strong>: 어떤 LLM이 함수 호출을 가장 정확하고 신뢰성 있게 생성하는지 평가하는 업계 표준 벤치마크다.</p></li>
<li><p><strong>최신 기술(OpenFunctions-v2)</strong>: 2025년 최첨단 함수 호출은 단일 함수 호출을 넘어선다. Gorilla의 OpenFunctions-v2는 “단일 프롬프트에 대해 여러 함수를 병렬로 호출”하거나 “제공된 목록에서 여러 적절한 함수를 선택”하는 것과 같은 복잡한 시나리오를 지원한다. 또한 Python, Java, REST API를 포함한 다양한 언어를 네이티브로 지원한다.</p></li>
</ul>
<p>이러한 “내재적” 능력의 발전은 미래에(Anthropic의 “에이전트 우선” 모델처럼) CrewAI와 같은 “외재적” 오케스트레이션 프레임워크가 더 얇아지고, LLM 자체의 내재적 함수 호출 능력에 더 많이 의존하게 될 것임을 시사한다. 그러나 2025년 기준으로, 내재적 함수 호출은 여전히 “왜 그 도구를 선택했는지”에 대한 “설명 가능성”이 부족하여 복잡한 프로덕션 환경에서 디버깅과 신뢰성이 지속적인 과제로 남아 있다.</p>
</section>
<section id="id16">
<h3>체크포인트 질문<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>에이전트 능력에 대한 외재적 접근법과 내재적 접근법의 근본적인 차이점은 무엇인가?</p></li>
<li><p>Toolformer의 “손실 기반 필터링” 방법이 도구 사용의 자기 지도 학습을 어떻게 가능하게 하는가?</p></li>
<li><p>프로덕션 환경에서 내재적 함수 호출의 현재 한계는 무엇인가?</p></li>
</ul>
</section>
</section>
<section id="mast-2025">
<h2>8. 프로덕션 에이전트는 왜 실패하는가? - MAST 실패 분류법(2025)<a class="headerlink" href="#mast-2025" title="Link to this heading">#</a></h2>
<p>에이전트 시스템이 프로덕션에 배포되면, 단순히 “성능이 나쁘다”는 수준이 아니라 <em>붕괴</em>한다. 2025년 3월(v1)과 10월(v3)에 출판된 버전이 있는 arXiv 논문(arXiv:2503.13657)은 이러한 실패 원인에 대한 체계적인 분석을 제시한다: MAST(Multi-Agent System Failure Taxonomy).</p>
<p>이 연구에서 가장 중요한 교훈은 에이전트 시스템이 “LLM(예: GPT-4)이 충분히 똑똑하지 않아서” 실패하는 것이 아니라는 것이다. 실패의 근본 원인은 “결함 있는 조직 구조”—즉, <em>시스템 설계</em>다.</p>
<section id="mast-3">
<h3>8.1. MAST: 3가지 주요 실패 범주와 실제 사례<a class="headerlink" href="#mast-3" title="Link to this heading">#</a></h3>
<p>MAST는 14가지 고유한 실패 모드를 3가지 상위 범주로 분류한다:</p>
<p><strong>1. 명세 문제(Specification Issues, 실패의 41.8%)</strong></p>
<ul class="simple">
<li><p><strong>원인</strong>: 결함 있는 초기 설정</p></li>
<li><p><strong>상세 모드</strong>: 작업 명세 불이행, 역할 제약 조건 누락, 종료 기준 부재, 또는 열악한 작업 분해</p></li>
<li><p><strong>프로덕션 해결책</strong>: CrewAI의 명시적 역할, 목표, backstory 정의와 “Flows”의 결정적 워크플로우가 이 문제를 완화한다.</p></li>
</ul>
<p><strong>2. 에이전트 간 불일치(Inter-Agent Misalignment, 36.9%)</strong></p>
<ul class="simple">
<li><p><strong>원인</strong>: 실행 중 발생하는 의사소통 오류</p></li>
<li><p><strong>상세 모드</strong>: 다른 에이전트의 입력 무시, 컨텍스트 전파 실패</p></li>
<li><p><strong>중요 사례</strong>: “계획 에이전트가 YAML 형식으로 작업을 할당했지만, 실행 에이전트는 JSON 형식을 기대했다.” 이 작은 불일치가 전체 워크플로우를 중단시킨다.</p></li>
<li><p><strong>프로덕션 해결책</strong>: Mirascope의 <code class="docutils literal notranslate"><span class="pre">response_model=PydanticModel</span></code>은 모든 에이전트 간 I/O를 <em>타입 안전 객체</em>로 강제하여 이러한 형식 불일치를 방지한다.</p></li>
</ul>
<p><strong>3. 작업 검증 실패(Task Verification Failures, 21.3%)</strong></p>
<ul class="simple">
<li><p><strong>원인</strong>: 부적절한 품질 관리</p></li>
<li><p><strong>상세 모드</strong>: “판단(Judge)” 에이전트 부재, 조기 종료, 또는 검증 단계 누락</p></li>
<li><p><strong>중요 사례</strong>: 검증 에이전트가 “코드가 컴파일되는가?”와 같은 <em>얕은 검사</em>만 수행한다(예: 체스 프로그램이 컴파일되지만 잘못된 게임 규칙으로 플레이함).</p></li>
<li><p><strong>프로덕션 해결책</strong>: Haystack의 “에이전트형 RAG”가 ConditionalRouter를 사용하여 명시적 검증 단계(예: “no_answer” 확인)를 추가하는 것이 이 문제에 대한 직접적인 해결책이다.</p></li>
</ul>
</section>
<section id="id17">
<h3>8.2. 핵심 표: MAST - 멀티 에이전트 시스템 실패 분류법(2025)<a class="headerlink" href="#id17" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p>실패 범주</p></th>
<th class="head text-left"><p>발생률</p></th>
<th class="head text-left"><p>설명</p></th>
<th class="head text-left"><p>본 강의의 프로덕션 해결책</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>1. 명세 문제</p></td>
<td class="text-left"><p>41.8%</p></td>
<td class="text-left"><p>결함 있는 프롬프트, 역할/제약 조건 누락, 작업 분해 실패.</p></td>
<td class="text-left"><p>CrewAI: 명확한 역할, 목표 정의. CrewAI Flows: “명세”를 결정적 코드로 강제.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>2. 에이전트 간 불일치</p></td>
<td class="text-left"><p>36.9%</p></td>
<td class="text-left"><p>통신 실패, 컨텍스트 손실, 데이터 형식 불일치(예: YAML vs. JSON).</p></td>
<td class="text-left"><p>Mirascope: <code class="docutils literal notranslate"><span class="pre">response_model</span></code>을 Pydantic 객체로 강제하여 에이전트 간 타입 안전 I/O 보장.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>3. 작업 검증 실패</p></td>
<td class="text-left"><p>21.3%</p></td>
<td class="text-left"><p>“판단” 에이전트 부재, 얕은 검사, 오류 인식 없이 조기 종료.</p></td>
<td class="text-left"><p>Haystack(에이전트형 RAG): ConditionalRouter를 “검증” 단계로 사용하여 컨텍스트 품질을 확인하고 폴백 계획을 실행.</p></td>
</tr>
</tbody>
</table>
</div>
<p>이 표는 2025년의 3가지 주요 프로덕션 과제(MAST)와 우리가 학습한 3가지 핵심 프레임워크(CrewAI, Mirascope, Haystack) 간의 직접적인 1:1 매핑을 보여준다. 이는 이러한 프레임워크가 “트렌드”가 아니라 실제 프로덕션 “필요”에서 태어났음을 증명한다. 따라서 이 세 프레임워크는 개별 경쟁자로 보아서는 안 되며, 프로덕션 시스템을 구축하기 위해 함께 사용할 “솔루션 스택”으로 봐야 한다.</p>
</section>
<section id="id18">
<h3>체크포인트 질문<a class="headerlink" href="#id18" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>MAST 실패 분류법이 무엇이며, 프로덕션 에이전트 실패를 이해하는 데 왜 중요한가?</p></li>
<li><p>가장 높은 발생률을 가진 실패 범주는 무엇이며, 주요 원인은 무엇인가?</p></li>
<li><p>세 가지 프레임워크(CrewAI, Mirascope, Haystack)가 세 가지 MAST 실패 범주에 어떻게 매핑되는가?</p></li>
</ul>
</section>
</section>
<section id="id19">
<h2>9. [실습] 자동화된 고객 지원 시스템 프로토타입 설계<a class="headerlink" href="#id19" title="Link to this heading">#</a></h2>
<section id="id20">
<h3>9.1. 목표<a class="headerlink" href="#id20" title="Link to this heading">#</a></h3>
<p>세 가지 핵심 프레임워크(CrewAI, Haystack, Mirascope)의 강점과 MAST 실패 분류법의 교훈을 통합하여 강의 계획서에서 요구하는 “자동화된 고객 지원 시스템”을 위한 프로덕션 수준의 하이브리드 아키텍처를 설계한다.</p>
</section>
<section id="flow-calls-rag-calls-crew">
<h3>9.2. 아키텍처 청사진: “Flow-calls-RAG-calls-Crew” 하이브리드<a class="headerlink" href="#flow-calls-rag-calls-crew" title="Link to this heading">#</a></h3>
<p>단순한 CrewAI 스크립트를 넘어서 각 프레임워크의 강점을 활용하고 MAST에서 식별된 약점을 피하는 견고한 시스템을 설계한다.</p>
</section>
<section id="id21">
<h3>9.3. 1단계: 데이터 무결성 정의(Mirascope + Pydantic)<a class="headerlink" href="#id21" title="Link to this heading">#</a></h3>
<p>먼저 전체 시스템의 “상태(State)” 역할을 할 Pydantic 모델을 정의한다. 이는 근원에서 “에이전트 간 불일치” 실패를 방지하는 “계약”이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pydantic</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CustomerTicketState</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    전체 시스템을 위한 공유 상태 객체.</span>
<span class="sd">    Mirascope의 타입 안전성 철학을 적용한다.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_query</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">customer_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="s2">&quot;faq_answered&quot;</span><span class="p">,</span> <span class="s2">&quot;escalated&quot;</span><span class="p">,</span> <span class="s2">&quot;ticket_created&quot;</span><span class="p">]</span>
    <span class="n">category</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;billing&quot;</span><span class="p">,</span> <span class="s2">&quot;technical&quot;</span><span class="p">,</span> <span class="s2">&quot;general&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">]</span>
    <span class="n">priority</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;low&quot;</span><span class="p">,</span> <span class="s2">&quot;medium&quot;</span><span class="p">,</span> <span class="s2">&quot;high&quot;</span><span class="p">]</span>
    <span class="n">faq_response</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">final_summary</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ticket_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="crewai-flows">
<h3>9.4. 2단계: 전체 오케스트레이션(CrewAI Flows)<a class="headerlink" href="#crewai-flows" title="Link to this heading">#</a></h3>
<p>이것은 시스템의 “뇌” 역할을 하며 CustomerTicketState 객체를 관리한다. “명세 문제”를 해결하기 위해 자율적인 Crew가 아닌 결정적 Flows 아키텍처를 메인 컨트롤러로 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">crewai.flow</span><span class="w"> </span><span class="kn">import</span> <span class="n">Flow</span>

<span class="nd">@Flow</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomerSupportFlow</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    메인 오케스트레이터.</span>
<span class="sd">    &#39;CustomerTicketState&#39; 객체를 관리하고 단계를 진행한다.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_model</span><span class="o">=</span><span class="n">CustomerTicketState</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state_model</span>

    <span class="nd">@step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># 상태 초기화</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">original_query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;new&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
        <span class="c1"># 1단계: FAQ 에이전트 실행</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">start_at</span><span class="o">=</span><span class="s2">&quot;run_faq_agent&quot;</span><span class="p">)</span>

    <span class="nd">@step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_faq_agent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 3.1단계: Haystack 에이전트형 RAG 호출</span>
        <span class="n">response</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">faq_rag_agent</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">original_query</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;answered&quot;</span><span class="p">:</span>
            <span class="c1"># FAQ로 해결됨 -&gt; 플로우 종료</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;faq_answered&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">faq_response</span> <span class="o">=</span> <span class="n">response</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="nb">next</span><span class="o">=</span><span class="s2">&quot;end_flow&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># FAQ로 해결 불가 -&gt; 2단계(티켓팅)로 에스컬레이션</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;escalated&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="nb">next</span><span class="o">=</span><span class="s2">&quot;run_triage_crew&quot;</span><span class="p">)</span>

    <span class="nd">@step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_triage_crew</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 3.2단계: CrewAI Crew 호출</span>
        <span class="c1"># &#39;Flows&#39;가 &#39;Crews&#39;를 호출하고 상태 객체를 전달</span>
        <span class="n">updated_state</span> <span class="o">=</span> <span class="n">triage_crew</span><span class="o">.</span><span class="n">kickoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">model_dump</span><span class="p">())</span>  <span class="c1"># 딕셔너리로 전달</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CustomerTicketState</span><span class="p">(</span><span class="o">**</span><span class="n">updated_state</span><span class="p">)</span>  <span class="c1"># Pydantic으로 재검증</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="nb">next</span><span class="o">=</span><span class="s2">&quot;end_flow&quot;</span><span class="p">)</span>

    <span class="nd">@step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">end_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 최종 상태 반환</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</section>
<section id="faq-haystack-rag">
<h3>9.5. 3.1단계: 1차 응답 - FAQ 봇(Haystack 에이전트형 RAG)<a class="headerlink" href="#faq-haystack-rag" title="Link to this heading">#</a></h3>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">run_faq_agent</span></code> 단계에서 호출되는 에이전트다. “작업 검증”을 수행하기 위해 Haystack의 에이전트형 RAG를 사용하여 내부 FAQ DB를 검색한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># (의사 코드 - Haystack 파이프라인 구성)</span>

<span class="c1"># 1. &#39;no_answer&#39;를 반환하도록 프롬프트가 수정된 LLM</span>
<span class="n">qa_llm</span> <span class="o">=</span> <span class="n">OpenAIChatGenerator</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-4o-mini&quot;</span><span class="p">,</span>
    <span class="n">prompt_template</span><span class="o">=</span><span class="s2">&quot;...컨텍스트가 충분하지 않으면 &#39;no_answer&#39;를 반환하라.&quot;</span><span class="p">)</span>

<span class="c1"># 2. 조건부 라우터(에이전트형 RAG의 핵심)</span>
<span class="n">router</span> <span class="o">=</span> <span class="n">ConditionalRouter</span><span class="p">(</span><span class="n">routes</span><span class="o">=</span><span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;condition&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;no_answer&#39; in replies&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="s2">&quot;fallback&quot;</span><span class="p">,</span><span class="o">...</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;condition&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;no_answer&#39; not in replies&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="s2">&quot;answer&quot;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span>
<span class="p">])</span>

<span class="c1"># 3. 파이프라인</span>
<span class="n">rag_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
<span class="n">rag_pipeline</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;retriever&quot;</span><span class="p">,</span> <span class="n">InMemoryBM25Retriever</span><span class="p">(</span><span class="n">document_store</span><span class="o">=...</span><span class="p">))</span>
<span class="n">rag_pipeline</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;prompt_builder&quot;</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>
<span class="n">rag_pipeline</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;qa_llm&quot;</span><span class="p">,</span> <span class="n">qa_llm</span><span class="p">)</span>
<span class="n">rag_pipeline</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;router&quot;</span><span class="p">,</span> <span class="n">router</span><span class="p">)</span>  <span class="c1"># 검증 단계</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FAQAgent</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rag_pipeline</span><span class="o">.</span><span class="n">run</span><span class="p">({</span><span class="s2">&quot;query&quot;</span><span class="p">:</span> <span class="n">query</span><span class="p">,</span> <span class="s2">&quot;prompt_builder&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;query&quot;</span><span class="p">:</span> <span class="n">query</span><span class="p">}})</span>
        <span class="k">if</span> <span class="s2">&quot;answer&quot;</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;router&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;router&quot;</span><span class="p">][</span><span class="s2">&quot;answer&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="s2">&quot;answered&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># &#39;fallback&#39;이 트리거됨(답변을 찾지 못함)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;escalated&quot;</span>

<span class="n">faq_rag_agent</span> <span class="o">=</span> <span class="n">FAQAgent</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="crewai-crew">
<h3>9.6. 3.2단계: 2차 응답 - 티켓팅 크루(CrewAI Crew)<a class="headerlink" href="#crewai-crew" title="Link to this heading">#</a></h3>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">run_triage_crew</span></code> 단계에서 호출되는 “전문 팀(Crew)”이다. FAQ 봇이 실패하면 에스컬레이션된 CustomerTicketState를 받아 티켓 발행이라는 복잡한 작업을 수행한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">crewai</span><span class="w"> </span><span class="kn">import</span> <span class="n">Agent</span><span class="p">,</span> <span class="n">Task</span><span class="p">,</span> <span class="n">Crew</span><span class="p">,</span> <span class="n">Process</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">crewai_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseTool</span>

<span class="c1"># 도구 정의(예: DB 조회, 티켓 생성)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomerDBTool</span><span class="p">(</span><span class="n">BaseTool</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;고객 데이터베이스 조회&quot;</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;쿼리 텍스트로 고객 세부 정보를 조회한다.&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1">#... DB 조회 로직...</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;customer_id&quot;</span><span class="p">:</span> <span class="s2">&quot;C-123&quot;</span><span class="p">,</span> <span class="s2">&quot;priority&quot;</span><span class="p">:</span> <span class="s2">&quot;high&quot;</span><span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">JiraTicketTool</span><span class="p">(</span><span class="n">BaseTool</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Jira 티켓 생성기&quot;</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Jira에 새로운 지원 티켓을 생성한다.&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summary</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">category</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1">#... JIRA API 호출 로직...</span>
        <span class="k">return</span> <span class="s2">&quot;JIRA-TICKET-567&quot;</span>

<span class="c1"># 에이전트 1: 분류기(쿼리 + 상태 컨텍스트)</span>
<span class="n">classifier_agent</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span>
    <span class="n">role</span><span class="o">=</span><span class="s2">&quot;분류 전문가&quot;</span><span class="p">,</span>
    <span class="n">goal</span><span class="o">=</span><span class="s2">&quot;쿼리와 현재 상태를 분석하여 문제를 분류한다.&quot;</span><span class="p">,</span>
    <span class="n">backstory</span><span class="o">=</span><span class="s2">&quot;복잡한 지원 문제 라우팅 전문가.&quot;</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">)</span>

<span class="c1"># 에이전트 2: DB 조회(도구 사용)</span>
<span class="n">db_agent</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span>
    <span class="n">role</span><span class="o">=</span><span class="s2">&quot;데이터베이스 분석가&quot;</span><span class="p">,</span>
    <span class="n">goal</span><span class="o">=</span><span class="s2">&quot;쿼리에서 고객 ID를 찾고 우선순위를 위해 DB를 조회한다.&quot;</span><span class="p">,</span>
    <span class="n">backstory</span><span class="o">=</span><span class="s2">&quot;고객 데이터를 가져오기 위해 내부 시스템에 연결한다.&quot;</span><span class="p">,</span>
    <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">CustomerDBTool</span><span class="p">()]</span>
<span class="p">)</span>

<span class="c1"># 에이전트 3: 티켓 생성기(도구 사용 + 최종 요약)</span>
<span class="n">ticketing_agent</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span>
    <span class="n">role</span><span class="o">=</span><span class="s2">&quot;티켓팅 에이전트&quot;</span><span class="p">,</span>
    <span class="n">goal</span><span class="o">=</span><span class="s2">&quot;모든 정보를 요약하고 JIRA 티켓을 생성한다.&quot;</span><span class="p">,</span>
    <span class="n">backstory</span><span class="o">=</span><span class="s2">&quot;엔지니어를 위한 정보 포맷팅.&quot;</span><span class="p">,</span>
    <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">JiraTicketTool</span><span class="p">()]</span>
<span class="p">)</span>

<span class="c1"># 작업</span>
<span class="n">classify_task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;쿼리 분류: &#39;</span><span class="si">{original_query}</span><span class="s2">&#39;. 현재 상태: &#39;</span><span class="si">{status}</span><span class="s2">&#39;.&quot;</span><span class="p">,</span>
    <span class="n">agent</span><span class="o">=</span><span class="n">classifier_agent</span><span class="p">,</span>
    <span class="n">expected_output</span><span class="o">=</span><span class="s2">&quot;&#39;category&#39;(billing, technical, general)가 포함된 JSON.&quot;</span>
<span class="p">)</span>
<span class="n">db_task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;쿼리 &#39;</span><span class="si">{original_query}</span><span class="s2">&#39;에 대한 고객 세부 정보 조회.&quot;</span><span class="p">,</span>
    <span class="n">agent</span><span class="o">=</span><span class="n">db_agent</span><span class="p">,</span>
    <span class="n">context</span><span class="o">=</span><span class="p">[</span><span class="n">classify_task</span><span class="p">],</span>  <span class="c1"># 분류 후 실행</span>
    <span class="n">expected_output</span><span class="o">=</span><span class="s2">&quot;&#39;customer_id&#39;와 &#39;priority&#39;가 포함된 JSON.&quot;</span>
<span class="p">)</span>
<span class="n">ticket_task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;수집된 모든 정보를 사용하여 최종 티켓 생성.&quot;</span><span class="p">,</span>
    <span class="n">agent</span><span class="o">=</span><span class="n">ticketing_agent</span><span class="p">,</span>
    <span class="n">context</span><span class="o">=</span><span class="p">[</span><span class="n">db_task</span><span class="p">],</span>  <span class="c1"># DB 조회 후 실행</span>
    <span class="n">expected_output</span><span class="o">=</span><span class="s2">&quot;&#39;ticket_id&#39;가 포함된 최종 JSON 상태 업데이트.&quot;</span>
<span class="p">)</span>

<span class="n">triage_crew</span> <span class="o">=</span> <span class="n">Crew</span><span class="p">(</span>
    <span class="n">agents</span><span class="o">=</span><span class="p">[</span><span class="n">classifier_agent</span><span class="p">,</span> <span class="n">db_agent</span><span class="p">,</span> <span class="n">ticketing_agent</span><span class="p">],</span>
    <span class="n">tasks</span><span class="o">=</span><span class="p">[</span><span class="n">classify_task</span><span class="p">,</span> <span class="n">db_task</span><span class="p">,</span> <span class="n">ticket_task</span><span class="p">],</span>
    <span class="n">process</span><span class="o">=</span><span class="n">Process</span><span class="o">.</span><span class="n">sequential</span>  <span class="c1"># 순차적으로 실행</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id22">
<h3>9.7. 실습 아키텍처 요약<a class="headerlink" href="#id22" title="Link to this heading">#</a></h3>
<p>이 하이브리드 아키텍처는 2025년 프로덕션 시스템의 모든 요구사항을 충족한다:</p>
<ol class="arabic simple">
<li><p><strong>Mirascope(Pydantic)</strong>: “데이터 계약”인 CustomerTicketState를 정의하여 근원에서 “에이전트 간 불일치”를 방지한다.</p></li>
<li><p><strong>CrewAI Flows</strong>: 메인 오케스트레이터 역할을 하며 CustomerTicketState 객체를 관리하고 결정적 워크플로우를 보장한다(“명세 문제” 해결).</p></li>
<li><p><strong>Haystack 에이전트형 RAG</strong>: 1차 방어선(FAQ) 역할을 하며 ConditionalRouter를 통해 “작업 검증”을 수행하고 실패 시 안전하게 다음 단계로 플로우를 전달한다.</p></li>
<li><p><strong>CrewAI Crew</strong>: 2차 방어선(티켓팅) 역할을 하며 전문 에이전트(분류, DB, 생성)가 협력하여 복잡한 “작업 분해”를 수행한다.</p></li>
</ol>
<p>이는 2025년의 세 가지 주요 프로덕션 과제(MAST)를 모두 해결하는 견고한 아키텍처다.</p>
</section>
<section id="id23">
<h3>체크포인트 질문<a class="headerlink" href="#id23" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>하이브리드 아키텍처가 CrewAI, Mirascope, Haystack의 강점을 어떻게 결합하는가?</p></li>
<li><p>Pydantic 상태 모델이 에이전트 간 불일치를 방지하는 데 왜 중요한가?</p></li>
<li><p>FAQ 에이전트의 ConditionalRouter가 작업 검증을 어떻게 구현하는가?</p></li>
</ul>
</section>
</section>
<section id="id24">
<h2>10. 부록: 핵심 프레임워크 및 플랫폼 비교<a class="headerlink" href="#id24" title="Link to this heading">#</a></h2>
<section id="id25">
<h3>10.1. 핵심 표 2: 2025년 멀티 에이전트 프레임워크 비교<a class="headerlink" href="#id25" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p>프레임워크</p></th>
<th class="head text-left"><p>핵심 철학</p></th>
<th class="head text-left"><p>주요 아키텍처 모델</p></th>
<th class="head text-left"><p>프로덕션 적합성 및 2025년 현황</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>CrewAI</p></td>
<td class="text-left"><p>역할 기반 협업</p></td>
<td class="text-left"><p>Crews: 자율 팀(자율성↑) Flows: 결정적 워크플로우(제어↑)</p></td>
<td class="text-left"><p>높음. “Flows” 아키텍처와 AMP 플랫폼으로 프로덕션 준비 완료. 자율성과 제어의 균형.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>LangGraph</p></td>
<td class="text-left"><p>상태 기반 제어</p></td>
<td class="text-left"><p>순환 그래프</p></td>
<td class="text-left"><p>매우 높음. 노드 간 “상태”를 명시적으로 정의하고 전달. 복잡한 조건부 논리와 높은 디버깅 가능성이 필요한 작업에 최적.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Haystack</p></td>
<td class="text-left"><p>데이터 중심</p></td>
<td class="text-left"><p>파이프라인 + 라우터</p></td>
<td class="text-left"><p>높음(RAG 특화). “에이전트형 RAG” 개념을 통해 도메인 특화 지식 기반 에이전트 구축에 가장 강력함.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>AutoGen</p></td>
<td class="text-left"><p>대화형 협업</p></td>
<td class="text-left"><p>그룹 채팅</p></td>
<td class="text-left"><p>중간(연구). 에이전트 간 자연어 대화를 시뮬레이션. 유연하지만 예측 불가능하고 제어하기 어려움. 2025년 10월 Microsoft에 의해 <em>유지보수 모드</em>로 전환됨.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="id26">
<h3>10.2. 핵심 표 3: 로우코드 플랫폼 프로덕션 준비도 평가<a class="headerlink" href="#id26" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p>플랫폼</p></th>
<th class="head text-left"><p>핵심 기능</p></th>
<th class="head text-left"><p>프로토타이핑</p></th>
<th class="head text-left"><p>프로덕션 준비도(2025년 기준)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>LangFlow</p></td>
<td class="text-left"><p>LangChain 시각화(Python 기반)</p></td>
<td class="text-left"><p>우수함. 매우 빠르고 직관적.</p></td>
<td class="text-left"><p>매우 낮음(위험). “프로토타이핑 함정”. 심각한 메모리 누수, 캐싱, 동시성 문제. 재작성 가정.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>Flowise AI</p></td>
<td class="text-left"><p>LangChain 시각화(JS 기반)</p></td>
<td class="text-left"><p>우수함. 빠르고 직관적.</p></td>
<td class="text-left"><p>낮음. LangFlow와 유사한 확장성 한계. 전통적인 자동화 계층 부재.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>n8n</p></td>
<td class="text-left"><p>AI + 전통적 자동화</p></td>
<td class="text-left"><p>양호.</p></td>
<td class="text-left"><p>높음. 1000개 이상의 비즈니스 앱 통합 강점. AI 에이전트를 레거시 시스템에 연결하는 데 최적.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>CrewAI AMP</p></td>
<td class="text-left"><p>엔터프라이즈 에이전트 관리</p></td>
<td class="text-left"><p>우수함(No-Code)</p></td>
<td class="text-left"><p>매우 높음. 검증된 OSS 로직을 기반으로 비주얼 빌더, 모니터링, 배포, 거버넌스 제공.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="id27">
<h2>참고자료<a class="headerlink" href="#id27" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>What’s next for AI? - Deloitte, <a class="reference external" href="https://www.deloitte.com/us/en/insights/topics/technology-management/tech-trends/2025/tech-trends-ai-agents-and-autonomous-ai.html">https://www.deloitte.com/us/en/insights/topics/technology-management/tech-trends/2025/tech-trends-ai-agents-and-autonomous-ai.html</a></p></li>
<li><p>LLMs for Multi-Agent Cooperation | Xueguang Lyu, <a class="reference external" href="https://xue-guang.com/post/llm-marl/">https://xue-guang.com/post/llm-marl/</a></p></li>
<li><p>LangChain State of AI Agents Report, <a class="reference external" href="https://www.langchain.com/stateofaiagents">https://www.langchain.com/stateofaiagents</a></p></li>
<li><p>2025 Mid-Year LLM Market Update: Foundation Model Landscape + Economics, <a class="reference external" href="https://menlovc.com/perspective/2025-mid-year-llm-market-update/">https://menlovc.com/perspective/2025-mid-year-llm-market-update/</a></p></li>
<li><p>AI Agents in 2025: Expectations vs. Reality - IBM, <a class="reference external" href="https://www.ibm.com/think/insights/ai-agents-2025-expectations-vs-reality">https://www.ibm.com/think/insights/ai-agents-2025-expectations-vs-reality</a></p></li>
<li><p>Multi-Agent and Multi-LLM Architecture: Complete Guide for 2025 …, <a class="reference external" href="https://collabnix.com/multi-agent-and-multi-llm-architecture-complete-guide-for-2025/">https://collabnix.com/multi-agent-and-multi-llm-architecture-complete-guide-for-2025/</a></p></li>
<li><p>Designing Cooperative Agent Architectures in 2025 | Samira …, <a class="reference external" href="https://samiranama.com/posts/Designing-Cooperative-Agent-Architectures-in-2025/">https://samiranama.com/posts/Designing-Cooperative-Agent-Architectures-in-2025/</a></p></li>
<li><p>Hierarchical Multi-Agent Systems: Concepts and Operational Considerations - Over Coffee, <a class="reference external" href="https://overcoffee.medium.com/hierarchical-multi-agent-systems-concepts-and-operational-considerations-e06fff0bea8c">https://overcoffee.medium.com/hierarchical-multi-agent-systems-concepts-and-operational-considerations-e06fff0bea8c</a></p></li>
<li><p>#11: AIAgents -CrewAI: How Role-Based Agents Work Together | by Jayakrishnan M | Oct, 2025 | Medium, <a class="reference external" href="https://medium.com/&#64;jmelethil/11-aiagents-crewai-how-role-based-agents-work-together-87662ad25f33">https://medium.com/&#64;jmelethil/11-aiagents-crewai-how-role-based-agents-work-together-87662ad25f33</a></p></li>
<li><p>CrewAI Guide: Build Multi-Agent AI Teams in October 2025, <a class="reference external" href="https://mem0.ai/blog/crewai-guide-multi-agent-ai-teams">https://mem0.ai/blog/crewai-guide-multi-agent-ai-teams</a></p></li>
<li><p>Building Your First AI Customer Support System with CrewAI: A …, <a class="reference external" href="https://medium.com/&#64;tahaML/building-your-first-ai-customer-support-system-with-crewai-a-beginners-guide-f6a41f04fd2e">https://medium.com/&#64;tahaML/building-your-first-ai-customer-support-system-with-crewai-a-beginners-guide-f6a41f04fd2e</a></p></li>
<li><p>Introduction - CrewAI, <a class="reference external" href="https://docs.crewai.com/en/introduction">https://docs.crewai.com/en/introduction</a></p></li>
<li><p>Framework for orchestrating role-playing, autonomous AI agents. By fostering collaborative intelligence, CrewAI empowers agents to work together seamlessly, tackling complex tasks. - GitHub, <a class="github reference external" href="https://github.com/crewAIInc/crewAI">crewAIInc/crewAI</a></p></li>
<li><p>Crewai vs LangGraph: Know The Differences - TrueFoundry, <a class="reference external" href="https://www.truefoundry.com/blog/crewai-vs-langgraph">https://www.truefoundry.com/blog/crewai-vs-langgraph</a></p></li>
<li><p>Mastering Flow State Management - CrewAI, <a class="reference external" href="https://docs.crewai.com/en/guides/flows/mastering-flow-state">https://docs.crewai.com/en/guides/flows/mastering-flow-state</a></p></li>
<li><p>Crew AI, <a class="reference external" href="https://www.crewai.com/">https://www.crewai.com/</a></p></li>
<li><p>Why Do Multi-Agent LLM Systems Fail? | by Anna Alexandra …, <a class="reference external" href="https://thegrigorian.medium.com/why-do-multi-agent-llm-systems-fail-14dc34e0f3cb">https://thegrigorian.medium.com/why-do-multi-agent-llm-systems-fail-14dc34e0f3cb</a></p></li>
<li><p>Why Multi-Agent LLM Systems Fail: Key Issues Explained … - <a class="reference external" href="http://Orq.ai">Orq.ai</a>, <a class="reference external" href="https://orq.ai/blog/why-do-multi-agent-llm-systems-fail">https://orq.ai/blog/why-do-multi-agent-llm-systems-fail</a></p></li>
<li><p>Mirascope - LLMs Text Viewer | Mirascope, <a class="reference external" href="https://mirascope.com/docs/mirascope/llms-full">https://mirascope.com/docs/mirascope/llms-full</a></p></li>
<li><p>Response Models | Mirascope, <a class="reference external" href="https://mirascope.com/docs/mirascope/learn/response_models">https://mirascope.com/docs/mirascope/learn/response_models</a></p></li>
<li><p>Welcome - Mirascope, <a class="reference external" href="https://mirascope.com/docs/mirascope">https://mirascope.com/docs/mirascope</a></p></li>
<li><p>Structured Outputs - Mirascope, <a class="reference external" href="https://mirascope.com/docs/mirascope/guides/getting-started/structured-outputs">https://mirascope.com/docs/mirascope/guides/getting-started/structured-outputs</a></p></li>
<li><p>Haystack Documentation, <a class="reference external" href="https://docs.haystack.deepset.ai/docs/intro">https://docs.haystack.deepset.ai/docs/intro</a></p></li>
<li><p>Haystack vs. FlowiseAI: Comparing AI-Powered Development Platforms - SmythOS, <a class="reference external" href="https://smythos.com/developers/agent-comparisons/haystack-vs-flowiseai/">https://smythos.com/developers/agent-comparisons/haystack-vs-flowiseai/</a></p></li>
<li><p>Agents - Haystack Documentation, <a class="reference external" href="https://docs.haystack.deepset.ai/docs/agents">https://docs.haystack.deepset.ai/docs/agents</a></p></li>
<li><p>Build an Agentic RAG Pipeline in deepset Studio - Haystack, <a class="reference external" href="https://haystack.deepset.ai/blog/agentic-rag-in-deepset-studio">https://haystack.deepset.ai/blog/agentic-rag-in-deepset-studio</a></p></li>
<li><p>Building an Agentic RAG with Fallback to Websearch | Haystack, <a class="reference external" href="https://haystack.deepset.ai/tutorials/36_building_fallbacks_with_conditional_routing">https://haystack.deepset.ai/tutorials/36_building_fallbacks_with_conditional_routing</a></p></li>
<li><p>Why Do Multi-Agent LLM Systems Fail? - arXiv, <a class="reference external" href="https://arxiv.org/pdf/2503.13657">https://arxiv.org/pdf/2503.13657</a></p></li>
<li><p>Langflow | Low-code AI builder for agentic and RAG applications, <a class="reference external" href="https://www.langflow.org/">https://www.langflow.org/</a></p></li>
<li><p>Dify: Leading Agentic Workflow Builder, <a class="reference external" href="https://dify.ai/">https://dify.ai/</a></p></li>
<li><p>FlowiseAI vs. Langflow: Compare top AI agent builders - SmythOS, <a class="reference external" href="https://smythos.com/developers/agent-comparisons/flowiseai-vs-langflow/">https://smythos.com/developers/agent-comparisons/flowiseai-vs-langflow/</a></p></li>
<li><p>AI Agent Orchestration Frameworks: Which One Works Best for You …, <a class="reference external" href="https://blog.n8n.io/ai-agent-orchestration-frameworks/">https://blog.n8n.io/ai-agent-orchestration-frameworks/</a></p></li>
<li><p>CrewAI vs LangGraph vs AutoGen: Choosing the Right Multi-Agent AI Framework, <a class="reference external" href="https://www.datacamp.com/tutorial/crewai-vs-langgraph-vs-autogen">https://www.datacamp.com/tutorial/crewai-vs-langgraph-vs-autogen</a></p></li>
<li><p>9 AI Agent Frameworks Battle: Why Developers Prefer n8n, <a class="reference external" href="https://blog.n8n.io/ai-agent-frameworks/">https://blog.n8n.io/ai-agent-frameworks/</a></p></li>
<li><p>We Tried and Tested 8 Langflow Alternatives for Production-Ready AI Workflows - ZenML, <a class="reference external" href="https://www.zenml.io/blog/langflow-alternatives">https://www.zenml.io/blog/langflow-alternatives</a></p></li>
<li><p>LangFlow vs Flowise vs n8n vs Make - Reddit, <a class="reference external" href="https://www.reddit.com/r/langflow/comments/1ij66dl/langflow_vs_flowise_vs_n8n_vs_make/">https://www.reddit.com/r/langflow/comments/1ij66dl/langflow_vs_flowise_vs_n8n_vs_make/</a></p></li>
<li><p>We Tried and Tested 8 Langflow Alternatives for Production-Ready …, <a class="reference external" href="https://zenml.io/blog/langflow-alternatives">https://zenml.io/blog/langflow-alternatives</a></p></li>
<li><p>The Best Langflow vs Flowise Comparison to Guide Your AI Tool Decision - <a class="reference external" href="http://Lamatic.ai">Lamatic.ai</a> Labs, <a class="reference external" href="https://blog.lamatic.ai/guides/langflow-vs-flowise/">https://blog.lamatic.ai/guides/langflow-vs-flowise/</a></p></li>
<li><p>Toolformer: Language Models Can Teach Themselves to Use Tools | Research - AI at Meta, <a class="reference external" href="https://ai.meta.com/research/publications/toolformer-language-models-can-teach-themselves-to-use-tools/">https://ai.meta.com/research/publications/toolformer-language-models-can-teach-themselves-to-use-tools/</a></p></li>
<li><p>Toolformer: How Language Models Learn to Use Tools by … - Medium, <a class="reference external" href="https://medium.com/&#64;darshantank_55417/toolformer-how-language-models-learn-to-use-tools-by-themselves-9724fb64ed0e">https://medium.com/&#64;darshantank_55417/toolformer-how-language-models-learn-to-use-tools-by-themselves-9724fb64ed0e</a></p></li>
<li><p>Improving Large Language Models Function Calling and Interpretability via Guided-Structured Templates - arXiv, <a class="reference external" href="https://arxiv.org/html/2509.18076v1">https://arxiv.org/html/2509.18076v1</a></p></li>
<li><p>FunReason: Enhancing Large Language Models’ Function Calling via Self-Refinement Multiscale Loss and Automated Data Refinement - arXiv, <a class="reference external" href="https://arxiv.org/html/2505.20192v1">https://arxiv.org/html/2505.20192v1</a></p></li>
<li><p>[2305.15334] Gorilla: Large Language Model Connected with Massive APIs - arXiv, <a class="reference external" href="https://arxiv.org/abs/2305.15334">https://arxiv.org/abs/2305.15334</a></p></li>
<li><p>Gorilla, <a class="reference external" href="https://gorilla.cs.berkeley.edu/">https://gorilla.cs.berkeley.edu/</a></p></li>
<li><p>Why Do Multi-Agent LLM Systems Fail? - arXiv, <a class="reference external" href="https://arxiv.org/html/2503.13657v2">https://arxiv.org/html/2503.13657v2</a></p></li>
<li><p>[2503.13657] Why Do Multi-Agent LLM Systems Fail? - arXiv, <a class="reference external" href="https://arxiv.org/abs/2503.13657">https://arxiv.org/abs/2503.13657</a></p></li>
<li><p>WHY DO MULTI-AGENT LLM SYSTEMS FAIL? - OpenReview, <a class="reference external" href="https://openreview.net/pdf?id=wM521FqPvI">https://openreview.net/pdf?id=wM521FqPvI</a></p></li>
<li><p>AutoGen vs CrewAI vs LangGraph: AI Framework Comparison 2025 - JetThoughts, <a class="reference external" href="https://jetthoughts.com/blog/autogen-crewai-langgraph-ai-agent-frameworks-2025/">https://jetthoughts.com/blog/autogen-crewai-langgraph-ai-agent-frameworks-2025/</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "entelecheia/deepnlp-2025",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./week11"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
    <div class="giscus"></div>
<script src="https://giscus.app/client.js"        data-repo="entelecheia/deepnlp-2025"        data-repo-id="R_kgDOPjTLcA"        data-category="General"        data-category-id="DIC_kwDOPjTLcM4Cuy8e"        data-mapping="pathname"        data-strict="1"        data-reactions-enabled="1"        data-emit-metadata="1"        data-input-position="bottom"        data-theme="noborder_light"        data-lang="ko"        data-loading="lazy"        crossorigin="anonymous"        async></script>
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../week10/index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Week 10: 정렬 기법의 발전</p>
      </div>
    </a>
    <a class="right-next"
       href="../week12/index.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Week 12: AI 규제와 책임 있는 AI</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">1. 서론: 2025년, 프로덕션 에이전트 시스템의 새벽</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qa-llm-mas">1.1. 패러다임 전환: 단일 QA 봇에서 멀티 에이전트 시스템(LLM-MAS)으로</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#llm">1.2. 2025년 시장 동향: “에이전트 우선” LLM의 부상</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">1.3. “프로덕션”의 진정한 의미: “신뢰”와의 전투</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">2. 멀티 에이전트 협업 아키텍처의 이론적 기초</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">2.1. 주요 아키텍처 패턴 상세 분석</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai">3. CrewAI: 역할 기반 협업 오케스트레이션</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">3.1. 핵심 철학: 역할 기반 자율성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crews-vs-flows">3.2. 2025년 핵심 아키텍처: “Crews” vs “Flows”</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">3.3. 상태 관리의 중요성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai-amp-agent-management-platform">3.4. 엔터프라이즈 동향: CrewAI AMP(Agent Management Platform)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mirascope-pydantic">4. Mirascope: Pydantic을 통한 타입 안전성</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">4.1. 프로덕션 병목: 비구조화된 LLM 출력의 신뢰성 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mirascope-pydantic-i-o">4.2. Mirascope의 해결책: Pydantic을 통한 구조화된 I/O</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sdk">4.3. 네이티브 SDK와 비교한 압도적 단순성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#haystack-agents-rag">5. Haystack Agents: 도메인 특화 “에이전트형 RAG”</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-rag-rag">5.1. RAG의 진화: 수동적 RAG에서 능동적 “에이전트형 RAG”로</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conditionalrouter">5.2. 핵심 구성 요소: ConditionalRouter</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">6. 로우코드 통합 플랫폼과 “프로토타이핑 함정”</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#flowise-langflow-n8n">6.1. 비주얼 워크플로우 빌더(Flowise, LangFlow, n8n)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">6.2. 2025년의 냉혹한 현실: “프로토타이핑 함정”</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#llm-toolformer">7. LLM 내재적 능력의 진화: Toolformer에서 차세대 함수 호출로</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vs">7.1. 두 가지 접근법: 외재적 프레임워크 vs 내재적 능력</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#toolformer">7.2. 기초 연구: Toolformer와 자기 지도 학습</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gorilla-llm-berkeley-function-calling-leaderboard-bfcl">7.3. 2025년 현황: Gorilla LLM과 Berkeley Function Calling Leaderboard(BFCL)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mast-2025">8. 프로덕션 에이전트는 왜 실패하는가? - MAST 실패 분류법(2025)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mast-3">8.1. MAST: 3가지 주요 실패 범주와 실제 사례</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">8.2. 핵심 표: MAST - 멀티 에이전트 시스템 실패 분류법(2025)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">9. [실습] 자동화된 고객 지원 시스템 프로토타입 설계</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">9.1. 목표</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#flow-calls-rag-calls-crew">9.2. 아키텍처 청사진: “Flow-calls-RAG-calls-Crew” 하이브리드</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">9.3. 1단계: 데이터 무결성 정의(Mirascope + Pydantic)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai-flows">9.4. 2단계: 전체 오케스트레이션(CrewAI Flows)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#faq-haystack-rag">9.5. 3.1단계: 1차 응답 - FAQ 봇(Haystack 에이전트형 RAG)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#crewai-crew">9.6. 3.2단계: 2차 응답 - 티켓팅 크루(CrewAI Crew)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">9.7. 실습 아키텍처 요약</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">체크포인트 질문</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">10. 부록: 핵심 프레임워크 및 플랫폼 비교</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">10.1. 핵심 표 2: 2025년 멀티 에이전트 프레임워크 비교</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">10.2. 핵심 표 3: 로우코드 플랫폼 프로덕션 준비도 평가</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">참고자료</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Young Joon Lee
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>
